(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Cholk = factory());
})(this, (function () { 'use strict';

    const STYLE$1 = {
        bold: 'font-weight: bold;',
        italic: 'font-style: italic;',
        underline: 'text-decoration: underline;',
        nil: ';',
        gap: 'margin-left: 0.5em;',
    };
    const PRESET$1 = {};
    let BASESTYLE = '';
    var STYLES = {
        STYLE: STYLE$1,
        PRESET: PRESET$1,
        BASESTYLE,
    };

    function appendStyle(target, style) {
        if (style.endsWith(';')) {
            const template = target._template;
            const params = target._params;
            if (template.endsWith('%c')) {
                params[params.length - 1] += style;
            }
            else {
                target._template += '%c';
                params.push(STYLES.BASESTYLE + style);
            }
        }
    }

    function applyParams(target, args) {
        let template = '';
        let params = [];
        for (let i of args) {
            if (typeof i === 'string') {
                template += '%s';
            }
            else {
                template += '%o';
            }
            params.push(i);
        }
        if (STYLES.BASESTYLE && !target._template) {
            appendStyle(target, ';');
        }
        target._template += template;
        target._params.push(...params);
    }

    function customColors(STYLE, colors) {
        for (let key in colors) {
            const value = colors[key];
            STYLE[key] = `color: ${value};`;
            STYLE[`bg${key.slice(0, 1).toUpperCase()}${key.slice(1)}`] = `background-color: ${value};`;
        }
    }

    function isTypeof(target, typeName) {
        return Object.prototype.toString.call(target).slice(8, -1) === typeName;
    }

    function customPreset(PRESET, preset) {
        if (!isTypeof(preset, 'Object')) {
            console.error('config.preset should be Object');
            return;
        }
        for (let [funcName, config] of Object.entries(preset)) {
            if (isTypeof(config, 'Object')) {
                PRESET[funcName] = config;
            }
            else {
                console.error(`config.preset.${funcName} should be Object`);
            }
        }
    }

    function customStyles(STYLE, styles) {
        for (let key in styles) {
            let value = `${styles[key]}`;
            if (!value.endsWith(';')) {
                value += ';';
            }
            STYLE[key] = value;
        }
    }

    /**
     * generateValues
     * 生成模板字符串
     * @param {object} cholk
     */
    function generateValues(cholk) {
        let tmpl = cholk._template;
        let params = [...cholk._params];
        const { _template: preTmpl = '', _params: preParams = [] } = cholk._prefix;
        const { _template: sufTmpl = '', _params: sufParams = [] } = cholk._suffix;
        // preTmpl could be one of %c、%c%s、%s
        if (preTmpl === '%c' && tmpl.startsWith('%c')) {
            // only style
            params[0] = preParams[0] + params[0];
        }
        else {
            tmpl = preTmpl + tmpl;
            params = [...preParams, ...params];
        }
        // sufTmpl could be one of %c、%c%s、%s
        if (tmpl.endsWith('%c') && sufTmpl.startsWith('%c')) {
            if (sufTmpl === '%c') {
                params[params.length - 1] = params[params.length - 1] + sufParams[0];
            }
            else if (sufTmpl === '%c%s') {
                tmpl = tmpl + '%s';
                const lastParam = params.pop();
                sufParams[0] = lastParam + sufParams[0];
                params = [...params, ...sufParams];
            }
        }
        else {
            tmpl += sufTmpl;
            params = [...params, ...sufParams];
        }
        return [tmpl, ...params];
    }

    /**
     * handleStyleValue
     * @param {string|string[]} value - colorName | styleName | cssValue | [colorName | styleName | cssValue, ...]
     * @returns {string}
     */
    function handleStyleValue(value) {
        if (!value)
            return '';
        if (typeof value === 'string') {
            value = [value];
        }
        if (!isTypeof(value, 'Array')) {
            console.error('StyleValue should be String or Array');
            return '';
        }
        const styles = [];
        for (let key of value) {
            if (typeof key === 'string') {
                if (key in STYLES.STYLE) {
                    styles.push(STYLES.STYLE[key]);
                }
                else {
                    if (!key.endsWith(';')) {
                        key += ';';
                    }
                    styles.push(key);
                }
            }
        }
        return styles.join('');
    }

    function handleAffix(affix = {}) {
        const target = {
            _template: '',
            _params: [],
        };
        affix?.css && appendStyle(target, handleStyleValue(affix?.css));
        affix?.log &&
            applyParams(target, isTypeof(affix?.log, 'Array') ? affix?.log : [affix?.log]);
        return target;
    }

    function handleLogValue(target, value) {
        target._presetLogger = function (...args) {
            if (typeof value === 'undefined')
                return [];
            if (typeof value === 'function') {
                value = value(...args);
            }
            if (isTypeof(value, 'Array')) {
                return value;
            }
            else {
                return [value];
            }
        };
    }

    function handlePresetCall(target, preset) {
        const { css, log } = preset;
        appendStyle(target, handleStyleValue(css));
        handleLogValue(target, log);
    }

    function resetStyle(target) {
        const template = target._template;
        const params = target._params;
        if (template.endsWith('%c')) {
            params[params.length - 1] = ';';
        }
        else {
            target._template += '%c';
            params.push(';');
        }
    }

    const { STYLE, PRESET } = STYLES;
    customColors(STYLE, {
        blue: '#1890ff',
        cyan: '#13c2c2',
        gold: '#faad14',
        green: '#52c41a',
        lime: '#a0d911',
        magenta: '#eb2f96',
        orange: '#fa8c16',
        pink: '#ffc0cb',
        purple: '#722ed1',
        red: '#f5222d',
        white: '#fff',
        yellow: '#fadb14',
        grey: '#5e5e5e', // 灰黑
    });
    const proxyHandler = {
        get: function (target, key, receiver) {
            if (key === 'css') {
                // redirect to function cholk.css()
                return target.css;
            }
            if (key === 'reset') {
                resetStyle(target);
                return receiver;
            }
            if (key in PRESET) {
                handlePresetCall(target, PRESET[key]);
                return target.presetHandler;
            }
            if (key in STYLE) {
                appendStyle(target, STYLE[key]);
                return receiver;
            }
            return Reflect.get(target, key, receiver);
        },
        set: function () {
            return false;
        },
    };
    /**
     * Cholk
     * @param {Object} setting
     * @param {Object} setting.prefix
     * @param {string|string[]} setting.prefix.css - colorName | styleName | cssValue | [colorName | styleName | cssValue, ...]
     * @param {string|string[]} setting.prefix.log - logValue | [logValue, ...]
     * @param {Object} setting.suffix
     * @param {string|string[]} setting.suffix.css - colorName | styleName | cssValue | [colorName | styleName | cssValue, ...]
     * @param {string|string[]} setting.suffix.log - logValue | [logValue, ...]
     * @returns proxyCholk
     *
     * setting: {
     *    prefix: {
     *        css: colorName | styleName | cssValue | [colorName | styleName | cssValue, ...],
     *        log: logValue | [logValue, ...]
     *      },
     *    suffix: {
     *        css: colorName | styleName | cssValue | [colorName | styleName | cssValue, ...],
     *        log: logValue | [logValue, ...]
     *      }
     * }
     */
    function Cholk(setting = {}) {
        let proxyCholk;
        const cholk = (...args) => {
            applyParams(cholk, args);
            return proxyCholk;
        };
        cholk._template = '';
        cholk._params = [];
        cholk._prefix = handleAffix(setting.prefix);
        cholk._suffix = handleAffix(setting.suffix);
        cholk._preset = function (...args) {
            return [];
        };
        cholk._presetLogger = cholk._preset;
        cholk.values = function () {
            return generateValues(cholk);
        };
        /**
         * css
         * cholk.css('color: #aabbcc;').bgBlue('cholk')
         * // => ['%c', 'color: #aabbcc;background-color: blue', 'cholk']
         */
        cholk.css = function (style) {
            if (typeof style === 'string') {
                appendStyle(cholk, style);
            }
            return proxyCholk;
        };
        cholk.presetHandler = function (...args) {
            const value = cholk._presetLogger(...args);
            // restore _presetLogger
            cholk._presetLogger = cholk._preset;
            // apply preset
            return cholk(...value);
        };
        cholk[Symbol.iterator] = function* () {
            yield* generateValues(cholk);
            cholk._template = '';
            cholk._params = [];
        };
        proxyCholk = new Proxy(cholk, proxyHandler);
        return proxyCholk;
    }
    /**
     * Cholk.extend
     * @param {*} config
     *
     * config: {
     *    colors: {
     *      [colorName]: colorValue  // accept css color value
     *    },
     *    styles: {
     *      [styleName]: cssValue // css rules
     *    },
     *    baseStyle: colorName | styleName | cssValue | [colorName | styleName | cssValue, ...]
     *    preset: {
     *      [funcName]: {
     *        css: colorName | styleName | cssValue | [colorName | styleName | cssValue, ...],
     *        log: logValue | [logValue, ...] | (...args) => logValue
     *      }
     *    },
     * }
     */
    Cholk.extend = function (config = {}) {
        const { colors = {}, styles = {}, preset = {}, baseStyle } = config;
        customColors(STYLE, colors);
        customStyles(STYLE, styles);
        customPreset(PRESET, preset);
        if (typeof baseStyle !== 'undefined') {
            STYLES.BASESTYLE = handleStyleValue(baseStyle);
        }
    };
    /**
     * Cholk.styles
     * Cholk.getStyle
     * Cholk.getStyles
     * @returns list of available styles
     */
    Cholk.styles =
        Cholk.getStyle =
            Cholk.getStyles =
                function () {
                    return {
                        ...STYLE,
                    };
                };

    return Cholk;

}));
